<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="ZxhuaDr"><title>Zxhua Z</title><meta name="description" content="A Blog Powered By Hexo"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/header.jpg" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Zxhua Z</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Blog</span></a><a href="https://github.com/Zxhua"> Zxhua</a><span>&</span><a href="https://github.com/Zxhua"> Zone</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a class="current" href="/">Home</a></li><li><a href="/about">Sobre</a></li><li><a href="/archives">Arquivo</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2017/07/15/教你偷懒之Android模板/">教你偷懒之Android模板</a></h3></div><div class="post-content"><p>Android Template话接上片博客，直接进入正题–Android Studio Template。 对于Android模板我可以拍胸脯的说，只要是使用studio的人无论你知不知道这个东西，你都使用过。如果你不信，那么咱们用事实说话，请看大屏幕…..怎么样，眼不眼熟。 是的没有错，这就是Android ...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-07-15</span><i class="fa fa-tag"></i></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2017/07/10/教你偷懒之APT/">教你偷懒之APT</a></h3></div><div class="post-content"><p>最近听说了一种可自动生成代码的技术–APT，作为一个能躺着绝对不坐着的有志青年，当然是绝对不会放过任何一种可以提升效率(toulan)的技术  
什么是APT？APT英文全称：Android annotation process tool是一种处理注释的工具，它对源代码文件进行检测找出其中的Annotation，...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-07-10</span><i class="fa fa-tag"></i><a class="tag" href="/tags/JavaPoet/" title="JavaPoet">JavaPoet </a><a class="tag" href="/tags/注解/" title="注解">注解 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2017/06/28/hook-proxy/">Hook之代理</a></h3></div><div class="post-content"><p>
Hook主要涉及到两个知识点“代理”和“反射”,只要对这两个知识点有一定的了解，并且准确找到hook点，那么Hook系统Api将很容易实现。接下来我们将简单介绍一下代理模式与反射，最后通过实战完成Hook系统ASM服务。

1.代理模式
代理是一种设计模式，提供了对目标对象另外的一种访问方式。实现在不改动目标对...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-06-28</span><i class="fa fa-tag"></i><a class="tag" href="/categories/hook/" title="hook">hook </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2017/06/03/设计模式笔记(十九)适配器设计模式/">设计模式笔记(十九)适配器设计模式</a></h3></div><div class="post-content"><p>What总结模式成员
Why优点: 
缺点: 
Where </p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-06-03</span><i class="fa fa-tag"></i></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2017/06/02/设计模式笔记(十七)创建型设计模式总结/">设计模式笔记(十七)创建型设计模式总结</a></h3></div><div class="post-content"><p>总结创建型设计模式,用来解决new关键字出现的地方和Constructor过程问题,常用的有单例设计模式,工厂方法设计模式,抽象工厂设计模式.
</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-06-02</span><i class="fa fa-tag"></i></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2017/06/01/设计模式笔记(十六)建造者设计模式/">设计模式笔记(十六)建造者设计模式</a></h3></div><div class="post-content"><p>What建造者设计模式(Builder Pattern),将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示,是一种对象创建型设计模式.
总结类实例化过程的封装,包括构造方法和初始化参数的封装.
模式成员Builder:抽象建造者,提供若干初始化抽象方法和构造方法的封装方法ConcreteB...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-06-01</span><i class="fa fa-tag"></i></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2017/05/31/设计模式笔记(十五)原型设计模式/">设计模式笔记(十五)原型设计模式</a></h3></div><div class="post-content"><p>What原型模式是创建型模式的一种,其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。
模式成员Prototype :抽象原型类,克隆方法的定义接口/类ConcretePrototype :具体原型类,实现Prototype   
 
...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-05-31</span><i class="fa fa-tag"></i></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2017/05/26/设计模式笔记(十四)工厂设计模式总结/">设计模式笔记(十四)工厂设计模式总结</a></h3></div><div class="post-content"><p>总结简单工厂和工厂方法解决一维数组问题,每增加一种属性对应只增加一种类型抽象工厂解决二维数组问题, 两个属性对应一个对象时,类型为二维数组,用不同工厂来控制一个维度,用不同方法来控制第二个维度,能顺利解决二维数组问题控制维度的方法:类、方法、方法参数,这三种方式都可以解决单一维度,任意两个相互组合解决两层维度的问...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-05-26</span><i class="fa fa-tag"></i></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2017/05/25/设计模式笔记(十三)抽象工厂设计模式/">设计模式笔记(十三)抽象工厂设计模式</a></h3></div><div class="post-content"><p>What抽象工厂模式（Abstract factory pattern）是一种对象创建型设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-05-25</span><i class="fa fa-tag"></i></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2017/05/24/设计模式笔记(十二)工厂方法设计模式/">设计模式笔记(十二)工厂方法设计模式</a></h3></div><div class="post-content"><p>What工厂方法模式（Factory method pattern）是一种实现了工厂概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。属于类创建型设计模式.
总结在简单工厂的基础上,定义一个创建对象的Factory接口，通过不同实现,创建不同对象.
模式成员Fa...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-05-24</span><i class="fa fa-tag"></i></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">Próximo</a></li></ul></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>